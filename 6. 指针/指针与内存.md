### 内存的申请与回收

| 函数声明      | 功能描述                                     |
| --------- | ---------------------------------------- |
| malloc()  | 未初始化，返回的是 void * 类型的指针（地址），该地址是本次申请的内存空间的首字节地址。 |
| calloc()  | 经过初始化的内存空间                               |
| realloc() | 可以实现内存分配和内存释放的功能                         |
| free()    | 内存回收                                     |

malloc()：因为 char 表示一个字节，malloc() 的返回类型通常被定义为指向 char 的指针。然而，从 ANSI C 标准开始，C使用一个新的类型：指向 void 的指针。该类型相当于一个“通用指针”。malloc() 函数可用于返回指向数组的指针，指向结构的指针等，所以通常该函数的返回值会被强制转换为匹配的类型。然而，把指向 void 的指针赋给任意类型的指针完全不用考虑类型匹配的问题。

![1500206358594](images/1500206358594.png)

动态创建一维数组

```c
void main(){
  	int arr_len = 10; // 指定生成的数组的长度
	int *arr = NULL;
	// 申请内存空间作为整形数组，空间大小是sizeof(int)*arr_len个字节
	arr = (int *)malloc(sizeof(int)*arr_len);
	// 将这块内存空间全部初始化为0
	memset(arr,0,sizeof(int)*arr_len);
	
	for(int i=0; i<arr_len; i++){ // 为整形数组的元素赋值
	  	arr[i] = i;
	}
	
	for(int i=0; i<arr_len; i++){ // 打印整形数组的元素的值
	  	printf("%d ", arr[i]);
	}
	
	printf("\n");
	free(arr); // 释放内存空间
}
```

动态创建二维数组

```c
#include <stdio.h>
void main()
{
	int u, v;			//	定义二维数组的长和宽
	printf("第一维为：");
	scanf("%d", &u);
	printf("第二维为：");
	scanf("%d", &v);
	int** array = (int**)malloc(sizeof(int*)* u);  //先创建第一维
	for (int i = 0; i < u; i++)
	{
		//在内层循环中动态创建第二维
		array[i] = (int*)malloc(sizeof(int)* v);
		for (int j = 0; j < v; j++)
		{
			array[i][j] = 0;		 //给数组元素复制
			printf("%d  ", array[i][j]);
		}
	}
	free(array);
	printf("\n");
}
```

```c
#include<stdio.h>  
#include<stdlib.h>  
  
void main1()  
{  
    int  *p =(int *) calloc(10, sizeof(int));//分配内存  
    printf("%p\n", p);//输出地址  
  
    for (int i = 0; i < 10; i++)  
    {  
        *(p + i) = i;//*(p+i)等价于p[i]  
    }  
  
    int *pnew = (int *)realloc(p, 100000);//变长  
    // realloc
  	// 第一种情况，后面的内存没人用，就直接拓展变长  
    // 第二种情况，后面的内存有人用，先分配新的长度，拷贝原来的内存，释放的原来的内存  
    printf("%p", pnew);  
  
    for (int i = 10; i < 25000; i++)  
    {  
        *(pnew + i) = i;  
    }  
  
    system("pause");  
}  
```

内存泄露：也称作“内存渗漏”，用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元，直到程序结束（即该内存空间使用完毕之后未回收），即所谓内存泄露。

- 无法把指针变量本身传递给一个函数

```c
void GetMemory(char *p, int num){
  	p = (char *)malloc(sizeof(char)*num);
}
int main(){
  	char *str = NULL;
  	GetMemory(str, 100); // str 仍然为NULL
  	strcopy(str, "hello"); // 运行时错误
  	free(str); // free 并没有起作用，内存泄露
  	return 0;
}
```

- 使用二级指针作函数参数去申请内存

```c
void GetMemory(char **p, int num){
  	*p = (char *)malloc(sizeof(char)*num); // 间接赋值是指针存在的最大意义
}
int main(){
  	char *str = NULL;
  	GetMemory(&str, 100);
  	strcopy(str, "hello"); // ok
  	cout<<str<<endl;
  	free(str); // ok
  	return 0;
}
```

- 查找不及格的学生成绩

假设一个年级有3个班级，每个班级有40个学生。考试后，学校要从这些学生的考试成绩中找出不及格的学生成绩

```c
#include <stdio.h>
#include <stdlib.h>
// 该函数的功能是申请内存空间
void create_array(int *** p, int cls_num, int stu_num)
{
	*p = (int **)calloc(sizeof(int *), cls_num); // 申请内存空间作为指针数组
	for (int i = 0; i < cls_num; i++)
	{
		// 申请内存空间作为整型数组，将数组首地址赋给指针数组的元素
		*(*p + i) = (int *)calloc(sizeof(int), stu_num);
	}
}
// 该函数的功能是获取输入的学生成绩并存入申请的内存空间中
void input_score(int ** arr, int cls_num, int stu_num)
{
	for (int i = 0; i < cls_num; i++)
	{
		printf("请输入第 %d 个班级的学生成绩：\n", i + 1);
		for (int j = 0; j < stu_num; j++)
		{
			scanf("%d", *(arr + i) + j); // 将输入的成绩赋给整型数组的元素
		}
	}
}
// 该函数的功能是打印出学生的成绩
void print_score(int ** arr, int cls_num, int stu_num)
{
	for (int i = 0; i < cls_num; i++)
	{
		printf("第 %d 个班级的学生成绩：\n", i + 1);
		for (int j = 0; j < stu_num; j++)
		{
			printf("%d  ", *(*(arr + i) + j)); // 将整型数组中存入的学生成绩打印出来
		}
		printf("\n");
	}
}
// 该函数的功能是打印出不及格的学生成绩
void print_fail_score(int ** arr, int cls_num, int stu_num)
{
	for (int i = 0; i < cls_num; i++)
	{
		printf("第 %d 个班级的学生的不及格成绩：\n", i + 1);
		for (int j = 0; j < stu_num; j++)
		{
			if (*(*(arr + i) + j) < 60) // 将整型数组中不及格的学生成绩打印出来
			{
				printf("%d  ", *(*(arr + i) + j));
			}
		}
		printf("\n");
	}
}
// 该函数的功能是销毁并回收刚才申请的内存空间
void distroy_array(int *** arr, int cls_num, int stu_num)
{
	for (int i = 0; i < cls_num; i++)
	{
		free(*(*arr + i));				// 首先销毁整型数组所占内存空间
	}
	free(*arr);							// 其次销毁指针数组所占内存空间
	*arr = NULL;						// 为防止野指针的存在,将二级指针赋值为0
}
void main()
{
	int cls_num, stu_num;
	int ** arr;
	printf("请输入班级数量：");
	scanf("%d", &cls_num);
	printf("请输入每个班级学生数量：");
	scanf("%d", &stu_num);
	create_array(&arr, cls_num, stu_num);
	input_score(arr, cls_num, stu_num);
	print_score(arr, cls_num, stu_num);
	print_fail_score(arr, cls_num, stu_num);
	distroy_array(&arr, cls_num, stu_num);
}
```

### 内存操作

| 函数声明      | 功能描述                            |
| --------- | ------------------------------- |
| memset()  | 用于对指定的内存空间进行初始化操作               |
| memcopy() | 将一块内存空间的内容复制到另一块内存空间中，不处理内存重叠问题 |
| memmove() | 将源内存区的内容复制到目标内存区，可以正确处理内存重叠问题   |
| memcmp()  | 比较两个内存空间中数据的大小                  |

![1499528179884](images/1499528179884.png)