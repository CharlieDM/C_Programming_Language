### 内存的申请与回收

| 函数声明      | 功能描述                                     |
| --------- | ---------------------------------------- |
| malloc()  | 未初始化，返回的是 void * 类型的指针（地址），该地址是本次申请的内存空间的首字节地址。 |
| calloc()  | 经过初始化的内存空间                               |
| realloc() | 可以实现内存分配和内存释放的功能                         |
| free()    | 内存回收                                     |

malloc()：因为 char 表示一个字节，malloc() 的返回类型通常被定义为指向 char 的指针。然而，从 ANSI C 标准开始，C使用一个新的类型：指向 void 的指针。该类型相当于一个“通用指针”。malloc() 函数可用于返回指向数组的指针，指向结构的指针等，所以通常该函数的返回值会被强制转换为匹配的类型。然而，把指向 void 的指针赋给任意类型的指针完全不用考虑类型匹配的问题。

![1500206358594](images/1500206358594.png)

### 如何使用malloc 函数

函数原型

```c
(void *)malloc(int size)
```

malloc 函数的返回值是一个void 类型的指针，参数为int 类型数据，即申请分配的内存大小，单位是byte。内存分配成功之后，malloc 函数返回这块内存的首地址。你需要一个指针来接收这个地址。但是由于函数的返回值是void *类型的，所以必须强制转换成你所接收的类型。也就是说，这块内存将要用来存储什么类型的数据。比如：

```c
char *p = (char *)malloc(100);
```

在堆上分配了100 个字节内存，返回这块内存的首地址，把地址强制转换成`char *`类型后赋给`char *`类型的指针变量p。同时告诉我们这块内存将用来存储char 类型的数据。也就是说你只能通过指针变量p 来操作这块内存。这块内存本身并没有名字，对它的访问是匿名访问。

动态创建一维数组

```c
void main(){
  	int arr_len = 10; // 指定生成的数组的长度
	int *arr = NULL;
	// 申请内存空间作为整形数组，空间大小是sizeof(int)*arr_len个字节
	arr = (int *)malloc(sizeof(int)*arr_len);
	// 将这块内存空间全部初始化为0
	memset(arr,0,sizeof(int)*arr_len);
	
	for(int i=0; i<arr_len; i++){ // 为整形数组的元素赋值
	  	arr[i] = i;
	}
	
	for(int i=0; i<arr_len; i++){ // 打印整形数组的元素的值
	  	printf("%d ", arr[i]);
	}
	
	printf("\n");
	free(arr); // 释放内存空间
}
```

动态创建二维数组

```c
#include <stdio.h>
void main()
{
	int u, v;			//	定义二维数组的长和宽
	printf("第一维为：");
	scanf("%d", &u);
	printf("第二维为：");
	scanf("%d", &v);
	int** array = (int**)malloc(sizeof(int*)* u);  //先创建第一维
	for (int i = 0; i < u; i++)
	{
		//在内层循环中动态创建第二维
		array[i] = (int*)malloc(sizeof(int)* v);
		for (int j = 0; j < v; j++)
		{
			array[i][j] = 0;		 //给数组元素复制
			printf("%d  ", array[i][j]);
		}
	}
	free(array);
	printf("\n");
}
```

```c
#include<stdio.h>  
#include<stdlib.h>  
  
void main1()  
{  
    int  *p =(int *) calloc(10, sizeof(int));//分配内存  
    printf("%p\n", p);//输出地址  
  
    for (int i = 0; i < 10; i++)  
    {  
        *(p + i) = i;//*(p+i)等价于p[i]  
    }  
  
    int *pnew = (int *)realloc(p, 100000);//变长  
    // realloc
  	// 第一种情况，后面的内存没人用，就直接拓展变长  
    // 第二种情况，后面的内存有人用，先分配新的长度，拷贝原来的内存，释放的原来的内存  
    printf("%p", pnew);  
  
    for (int i = 10; i < 25000; i++)  
    {  
        *(pnew + i) = i;  
    }  
  
    system("pause");  
}  
```

内存泄露：也称作“内存渗漏”，用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元，直到程序结束（即该内存空间使用完毕之后未回收），即所谓内存泄露。

- 无法把指针变量本身传递给一个函数

```c
void GetMemory(char *p, int num){
  	p = (char *)malloc(sizeof(char)*num);
}
int main(){
  	char *str = NULL;
  	GetMemory(str, 100); // str 仍然为NULL
  	strcopy(str, "hello"); // 运行时错误
  	free(str); // free 并没有起作用，内存泄露
  	return 0;
}
```

- 使用二级指针作函数参数去申请内存

```c
void GetMemory(char **p, int num){
  	*p = (char *)malloc(sizeof(char)*num); // 间接赋值是指针存在的最大意义
}
int main(){
  	char *str = NULL;
  	GetMemory(&str, 100);
  	strcopy(str, "hello"); // ok
  	cout<<str<<endl;
  	free(str); // ok
  	return 0;
}
```

- 查找不及格的学生成绩

假设一个年级有3个班级，每个班级有40个学生。考试后，学校要从这些学生的考试成绩中找出不及格的学生成绩

```c
#include <stdio.h>
#include <stdlib.h>
// 该函数的功能是申请内存空间
void create_array(int *** p, int cls_num, int stu_num)
{
	*p = (int **)calloc(sizeof(int *), cls_num); // 申请内存空间作为指针数组
	for (int i = 0; i < cls_num; i++)
	{
		// 申请内存空间作为整型数组，将数组首地址赋给指针数组的元素
		*(*p + i) = (int *)calloc(sizeof(int), stu_num);
	}
}
// 该函数的功能是获取输入的学生成绩并存入申请的内存空间中
void input_score(int ** arr, int cls_num, int stu_num)
{
	for (int i = 0; i < cls_num; i++)
	{
		printf("请输入第 %d 个班级的学生成绩：\n", i + 1);
		for (int j = 0; j < stu_num; j++)
		{
			scanf("%d", *(arr + i) + j); // 将输入的成绩赋给整型数组的元素
		}
	}
}
// 该函数的功能是打印出学生的成绩
void print_score(int ** arr, int cls_num, int stu_num)
{
	for (int i = 0; i < cls_num; i++)
	{
		printf("第 %d 个班级的学生成绩：\n", i + 1);
		for (int j = 0; j < stu_num; j++)
		{
			printf("%d  ", *(*(arr + i) + j)); // 将整型数组中存入的学生成绩打印出来
		}
		printf("\n");
	}
}
// 该函数的功能是打印出不及格的学生成绩
void print_fail_score(int ** arr, int cls_num, int stu_num)
{
	for (int i = 0; i < cls_num; i++)
	{
		printf("第 %d 个班级的学生的不及格成绩：\n", i + 1);
		for (int j = 0; j < stu_num; j++)
		{
			if (*(*(arr + i) + j) < 60) // 将整型数组中不及格的学生成绩打印出来
			{
				printf("%d  ", *(*(arr + i) + j));
			}
		}
		printf("\n");
	}
}
// 该函数的功能是销毁并回收刚才申请的内存空间
void distroy_array(int *** arr, int cls_num, int stu_num)
{
	for (int i = 0; i < cls_num; i++)
	{
		free(*(*arr + i));				// 首先销毁整型数组所占内存空间
	}
	free(*arr);							// 其次销毁指针数组所占内存空间
	*arr = NULL;						// 为防止野指针的存在,将二级指针赋值为0
}
void main()
{
	int cls_num, stu_num;
	int ** arr;
	printf("请输入班级数量：");
	scanf("%d", &cls_num);
	printf("请输入每个班级学生数量：");
	scanf("%d", &stu_num);
	create_array(&arr, cls_num, stu_num);
	input_score(arr, cls_num, stu_num);
	print_score(arr, cls_num, stu_num);
	print_fail_score(arr, cls_num, stu_num);
	distroy_array(&arr, cls_num, stu_num);
}
```

### 内存分析

```C++
char* toStr1() 
{
    char *s = "hello"; // 常量区
    return s;
}

char* toStr2() 
{
    char s[] = "hello"; // 栈
    return s;
}

int main()
{
  	cout << toStr1() << endl; // hello
    cout << toStr2() << endl; // 乱码
    return 0;
}
```

### 内存四区

- 栈区（stack）：由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
- 堆区（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表
- 全局区（静态区）（static），全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。  程序结束后由系统释放。
- 文字常量区：常量字符串就是放在这里的。程序结束后由系统释放
- 程序代码区：存放函数体的二进制代码。

```c
int a = 0; //全局初始化区
char *p1; //全局未初始化区
    
main()
{
    int b; //栈
    char s[] = "abc"; //栈
    char *p2; //栈
    char *p3 = "123456"; //"123456" 在常量区，p3在栈上。
    static int c =0;//全局（静态）初始化区
    p1 = (char *)malloc(10);    
    p2 = (char *)malloc(20);//分配得到10和20字节的区域就在堆区。
  
  	//"123456" 放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。
    strcpy(p1, "123456");      
} 
```

- 申请后系统的响应

栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 
堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

- 申请大小的限制

栈：在Windows下，栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS 下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 

堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 

所以在程序中自动变量数组（函数内部）不能很大，因为栈（这就是我们通常说的程序的堆栈段，大数组发生段溢出）的大小有限，而可以申请为全局变量，因为那是分配在静态区，大小不受限制。

- 申请效率的比较

栈由系统自动分配，速度较快。但程序员是无法控制的。 

堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。

另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活 

- 堆和栈中的存储内容 

栈： 在函数调用时，第一个进栈的是主函数中的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。 

当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 

堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。 

### 内存操作

| 函数声明      | 功能描述                            |
| --------- | ------------------------------- |
| memset()  | 用于对指定的内存空间进行初始化操作               |
| memcopy() | 将一块内存空间的内容复制到另一块内存空间中，不处理内存重叠问题 |
| memmove() | 将源内存区的内容复制到目标内存区，可以正确处理内存重叠问题   |
| memcmp()  | 比较两个内存空间中数据的大小                  |

![1499528179884](images/1499528179884.png)