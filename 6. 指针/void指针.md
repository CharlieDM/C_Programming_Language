### void * 万能指针

void * 无类型指针，也叫万能指针，可以指向任何类型的数据，在32位系统下，占4个字节。

这类指针指向一块内存，却没有告诉应用程序按什么类型去解读这块内存，所以无类型指针不能直接进行数据的存取操作，必须先转换成其它类型的指针才能将内存解读出来。

void * 类型的指针指向的内存是尚未确定类型的，因此我们后续可以使用强制类型转换，强行将其转为各种类型。这就是void类型的最终归宿——被强制类型转换成一个具体的类型。

C语言规定只有相同类型的指针才可以相互赋值

- void * 指针作为左值用于“接收”任意类型的指针
- void * 指针作为右值赋值给其它指针时需要强制类型转换

```c
int *p1 = NULL;
char *p2 = (char *)malloc(sizoeof(char)*20); 
```
void *指针可以指向任意变量的内存空间

```c
void *p = NULL;
int a = 10; 
p = (void *)&a; //指向变量时，最好转换为void *
//使用指针变量指向的内存时，转换为int * 
*( (int *)p ) = 11; 
printf("a = %d\n", a);
```

![1500178806133](images/1500178806133.png)

### void的作用

- 对函数参数的限定：当不需要传入参数时，即 `function (void);`
- 对函数返回值的限定：当函数没有返回值时，即 `void function(void);`

### void指针的作用

（1）void指针可以指向任意的数据类型，即任意类型的指针可以赋值给void指针

```c
int *a;
void *p;
p=a;
```
如果void指针赋值给其他类型，则需要强制转换；`a=（int *）p;`

（2）在ANSI C标准中不允许对void指针进行算术运算，因为没有特定的数据类型，即在内存中不知道移动多少个字节；而在GNU标准中，认为void指针和char指针等同。

### 应用

（1）void指针一般用于应用的底层，比如malloc函数的返回类型是void指针，需要再强制转换；
（2）文件句柄HANDLE也是void指针类型，这也是句柄和指针的区别；
（3）内存操作函数的原型也需要void指针限定传入参数：

```c
void * memcpy (void *dest, const void *src, size_t len);
void * memset (void *buffer, int c, size_t num );
```
（4）面向对象函数中底层对基类的抽象。