## 单向链表

单向链表(单链表)是链表的一种，它由节点组成，每个节点都包含下一个节点的指针。

单链表的示意图如下：

![单链表](https://alleniverson.gitbooks.io/data-structure-and-algorithms/content/assets/1.14.jpg)

表头为空，表头的后继节点是"节点10"(数据为10的节点)，"节点10"的后继节点是"节点20"(数据为10的节点)

### 单链表删除节点

![单链表](https://alleniverson.gitbooks.io/data-structure-and-algorithms/content/assets/1.15.jpg)

删除"节点30" 删除之前："节点20" 的后继节点为"节点30"，而"节点30" 的后继节点为"节点40"。 删除之后："节点20" 的后继节点为"节点40"。

### 单链表添加节点

![单链表](https://alleniverson.gitbooks.io/data-structure-and-algorithms/content/assets/1.16.jpg)

在"节点10"与"节点20"之间添加"节点15" 添加之前："节点10" 的后继节点为"节点20"。 添加之后："节点10" 的后继节点为"节点15"，而"节点15" 的后继节点为"节点20"。

单链表的特点是：节点的链接方向是单向的；相对于数组来说，单链表的的随机访问速度较慢，但是单链表删除/添加数据的效率很高。

## 双向链表

双向链表(双链表)是链表的一种。和单链表一样，双链表也是由节点组成，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。

双链表的示意图如下：

![双链表](https://alleniverson.gitbooks.io/data-structure-and-algorithms/content/assets/1.17.jpg)

表头为空，表头的后继节点为"节点10"(数据为10的节点)；"节点10"的后继节点是"节点20"(数据为10的节点)，"节点20"的前继节点是"节点10"；"节点20"的后继节点是"节点30"，"节点30"的前继节点是"节点20"；...；末尾节点的后继节点是表头。

### 双链表删除节点

![双链表](https://alleniverson.gitbooks.io/data-structure-and-algorithms/content/assets/1.18.jpg)

删除"节点30" 删除之前："节点20"的后继节点为"节点30"，"节点30" 的前继节点为"节点20"。"节点30"的后继节点为"节点40"，"节点40" 的前继节点为"节点30"。 删除之后："节点20"的后继节点为"节点40"，"节点40" 的前继节点为"节点20"。

### 双链表添加节点

![双链表](https://alleniverson.gitbooks.io/data-structure-and-algorithms/content/assets/1.19.jpg)

在"节点10"与"节点20"之间添加"节点15" 添加之前："节点10"的后继节点为"节点20"，"节点20" 的前继节点为"节点10"。 添加之后："节点10"的后继节点为"节点15"，"节点15" 的前继节点为"节点10"。"节点15"的后继节点为"节点20"，"节点20" 的前继节点为"节点15"。

## 代码实现

```c
//单链表节点 
struct Node
{
	int data;             //数据区域 
	struct Node *next;  //指针区域 
};
//链表结构 
struct SimLink
{
	struct Node* head;  //首节点 
	int length;          //链表长度 
};
//初始化 
void initLink(struct SimLink *link)
{
	link->head = NULL;  //初始化首节点为NULL 
	link->length = 0;
}
//取表元 
struct Node *getElement(struct SimLink *link, int pos)
{
	if (pos < 0 || pos > link->length)
	{
		return NULL;
	}
	struct Node *p = link->head;
	int i = 0;
	while( i < pos )
	{
		p = p->next;
		i++;
	}
	return p;
}
//插入数据 
int insert(struct SimLink* link, int pos, int val)
{
	if (pos < 0 || pos > link->length)
	{
		return 0;  //如果插入失败，则返回1 
	}
	//插入表头位置 
	if (pos == 0)
	{
		struct Node* pNew = (struct Node*)malloc(sizeof(struct Node)); 
		pNew->data = val;
		pNew->next = link->head;
		link->head = pNew;
	}
	else  //插入到非表头位置 
	{
		//首先找到插入点的前驱 
		struct Node* priv = getElement(link, pos - 1);
		struct Node* pNew = (struct Node*)malloc(sizeof(struct Node));
		pNew->data = val;
		pNew->next = priv->next;
		priv->next = pNew;
	}
	link->length++;  //更新链表长度 
	return 1;
}
//查找数据 
struct Node* find(struct SimLink* link, int value)
{
	struct Node* cur = link->head;
	while (cur != NULL) //比较过程  
		{
			if (cur->data == value) //检查当前节点的值是否匹配  
		{
				return cur;
 		}
 		else
 	{   //如果不匹配，则移动到下一个节点 
 				cur = cur->next;
 			}
 		}
 		return NULL;
 	}
//删除数据 
void delete(struct SimLink* link, int pos)
{
	if (pos < 0 || pos > link->length - 1)
	{
		return;
	}
	struct Node* del;
	//首节点的情况 
	if (pos == 0)
	{
			del = link->head;
			link->head = del->next;
			free(del);
	}
	else{
		//非首节点的情况 
		struct Node* priv = find(link, pos - 1); //先找到被删除节点的前驱 
		del = priv->next;    //定位要被删除的节点 
		priv->next = del->next;
		free(del);
	}
	link->length--;
 }
 //释放链表
 void freeLink(struct SimLink* link)
 {
	struct Node* p = link->head->next;
	while (p)
	{
		link->head->next = p->next;
		free(p);
		p = link->head->next;
	}
	link->length = 0;
}
 //显示链表内容 
 void printLink(struct SimLink* link)
 {
	struct Node* cur = link->head;
	if (link->length == 0)
	{
		printf("空表 \n");
		return;
	}
	do
	{
		printf("[%d] ", cur->data);
		cur = cur->next;
	} while (cur->next != NULL);
	printf("\n");
 }

 void main(int argc, char** argv)
 {
	//使用链表  
	struct SimLink link;
	initLink(&link);
	//插入数据 
	int i;
	for (i = 0; i < 7; i++)
	{
		//插入操作
		insert(&link, i, i);
	}
	printLink(&link);
	delete(&link, 3);
	printLink(&link);
	freeLink(&link);
 }
```